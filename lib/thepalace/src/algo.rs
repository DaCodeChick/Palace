//! Cryptographic algorithms used by The Palace protocol
//!
//! This module implements:
//! - CRC32 checksum calculation (Palace variant)
//! - Pseudo-CRC32 generation from counters
//! - Palace string encryption/decryption (XOR cipher)
//!
//! These implementations are based on the original Palace Mansion source code.

use thiserror::Error;

/// CRC32 magic seed value used by Palace
///
/// From the original Mansion source: `#define CRC_MAGIC 0xd9216290L`
const CRC_MAGIC: u32 = 0xD9216290;

/// CRC mask table from the original Palace source
///
/// This 256-entry table is used by the pseudo-CRC32 algorithm.
/// From crcmask.h in the Mansion source code.
const CRC_MASK: [u32; 256] = [
    0xebe19b94, 0x7604de74, 0xe3f9d651, 0x604fd612, 0xe8897c2c, 0xadc40920, 0x37ecdfb7, 0x334989ed,
    0x2834c33b, 0x8bd2fe15, 0xcbf001a7, 0xbd96b9d6, 0x315e2ce0, 0x4f167884, 0xa489b1b6, 0xa51c7a62,
    0x54622636, 0x0bc016fc, 0x68de2d22, 0x3c9d304c, 0x44fd06fb, 0xbbb3f772, 0xd637e099, 0x849aa9f9,
    0x5f240988, 0xf8373bb7, 0x30379087, 0xc7722864, 0xb0a2a643, 0xe3316071, 0x956fed7c, 0x966f937d,
    0x9945ae16, 0xf0b237ce, 0x223479a0, 0xd8359782, 0x05ae1b89, 0xe3653292, 0xc34eea0d, 0x2691dfc2,
    0xe9145f51, 0xd9aa7f35, 0xc7c4344e, 0x4370eba1, 0x1e43833e, 0x634bcf18, 0x0c50e26b, 0x06492118,
    0xf78b8bfe, 0x5f2bb95c, 0xa3eb54a6, 0x1e15a2f0, 0x6cc01887, 0xde4e7405, 0x1c1d7374, 0x85757feb,
    0xe372517e, 0x9b9979c7, 0xf37807e8, 0x18f97235, 0x645a149b, 0x9556c6cf, 0xf389119e, 0x1d6cbf85,
    0xa9760ce5, 0xa985c5ff, 0x5f4db574, 0x13176cac, 0x2f14aa85, 0xf520832c, 0xd21ee917, 0x6f307a5b,
    0xc1fb01c6, 0x19415378, 0x797fa2c3, 0x24f42481, 0x4f652c30, 0x39bc02ed, 0x11eda1d7, 0x8c79a136,
    0x6bd37a86, 0x80b354ee, 0xc424e066, 0xaae16427, 0x6bd3be12, 0x868d8e37, 0xd1d43c54, 0x4d62081f,
    0x433056d7, 0xf2e4cb02, 0x043fc5a2, 0x9da58ca4, 0x1ed63321, 0x20679f26, 0xb38a4758, 0x846419f7,
    0x6bdc6352, 0xabf2c24d, 0x40ac386c, 0x27588588, 0x5e1ab2e5, 0x76bdead4, 0x71444d32, 0x02fc6084,
    0x92db41fb, 0xef86baeb, 0xf7d8572a, 0xb75aeabf, 0x84dc5c93, 0xcbc13881, 0x641d6e73, 0x0cb27a99,
    0xded369a6, 0x617e5dfa, 0x248bd13e, 0xb8596d66, 0x9b36a9fa, 0x52edaf1c, 0x3c659784, 0x146df599,
    0x109fcae8, 0xc9ed4841, 0xbf593f49, 0xc94a6e73, 0x5afa0d2f, 0xb2035002, 0xcab31104, 0x7c4f5a82,
    0xeac93638, 0x63fc5385, 0xdf0cae06, 0x26e55be3, 0x2921b9b8, 0xb80b3408, 0x917e137d, 0x127a48bc,
    0xe031858a, 0x722213d7, 0x2dbc96fa, 0x5359f112, 0xab256019, 0x6e2a756e, 0x4dc62f76, 0x268832de,
    0x5980e578, 0xd338b668, 0xeee2e4d7, 0x1fff8fc6, 0x9b17ed10, 0xf3e6be0f, 0xc1ba9d78, 0xbb8693c5,
    0x24d57ec0, 0x5d640aed, 0xee87979b, 0x96323e11, 0xccbc1601, 0x0e83f43b, 0x2c2f7495, 0x5f150b2a,
    0x710a77e2, 0x281b51dc, 0x2385d03c, 0x67239bff, 0xa719e8f9, 0x21c3b9de, 0x26489c22, 0x0de68989,
    0xca758f0d, 0x417e8cd2, 0x67ed61f8, 0xd15fc001, 0x3ba2f272, 0x57e2f7a9, 0xe723b883, 0x914e43e1,
    0x71aa5b97, 0xfceb1be1, 0x7ffa4fd9, 0x67a0b494, 0x5e1c741e, 0xc8c2a5e6, 0xe13ba068, 0x24525548,
    0x397a9cf6, 0x3dddd4d6, 0xb626234c, 0x39e7b04d, 0x36ca279f, 0x89aea387, 0xcfe93789, 0x04e1761b,
    0x9d620edc, 0x6e9df1e7, 0x4a15dfa6, 0xd44641ac, 0x39796769, 0x6d062637, 0xf967af35, 0xddb4a233,
    0x48407280, 0xa9f22e7e, 0xd9878f67, 0xa05b3bc1, 0xe8c9237a, 0x81cec53e, 0x4be53e70, 0x60308e5e,
    0xf03de922, 0xa712af7b, 0xbb6168b4, 0xcc6c15b5, 0x2f202775, 0x304527e3, 0xd32bc1e6, 0xba958058,
    0xa01f7214, 0xc6e8d190, 0xab96f14b, 0x18669984, 0x4f93a385, 0x403b5b40, 0x580755f1, 0x59de50e8,
    0xf746729f, 0xff6f7d47, 0x8022ea34, 0xb24b0bcd, 0xf687a7cc, 0x7e95bab3, 0x8dc1583d, 0x0b443fe9,
    0xe6e45618, 0x224d746f, 0xf30624bb, 0xb7427258, 0xc78e19bf, 0xd1ee98a6, 0x66be7d3a, 0x791e342f,
    0x68cbaab0, 0xbbb5355d, 0x8dda9081, 0xdc2736dc, 0x573355ad, 0xc3ffec65, 0xe97f0270, 0xc6a265e8,
    0xd9d49152, 0x4bb35bdb, 0xa1c7bbe6, 0x15a3669a, 0xe69e1eb5, 0x7cdda410, 0x488609df, 0xd19678d3,
];

/// Errors that can occur during Palace encryption/decryption
#[derive(Error, Debug, Clone, PartialEq, Eq)]
pub enum PalaceCryptError {
    /// Input data exceeds maximum length
    #[error("Input length {1} exceeds maximum {0}")]
    Length(u8, usize),
}

/// Calculate Palace-specific CRC32 checksum
///
/// This is the actual Palace CRC algorithm from the Mansion source code.
/// It uses a simple rotate-left-with-carry and XOR operation.
///
/// Original C implementation:
/// ```c
/// unsigned LONG ComputeCRC(Ptr pt, LONG len)
/// {
///     unsigned LONG crc = CRC_MAGIC;
///     unsigned char *p = (unsigned char *) pt;
///     while (len--)
///         crc = ((crc << 1L) | ((crc & 0x80000000L)? 1 : 0)) ^ *(p++);
///     return crc;
/// }
/// ```
///
/// # Arguments
///
/// * `input` - Data to checksum
/// * `seed` - Initial CRC value (use `CRC_MAGIC` or 0 for standard operation)
///
/// # Returns
///
/// 32-bit CRC checksum
///
/// # Example
///
/// ```
/// use thepalace::algo::crc32;
///
/// let data = b"Hello, Palace!";
/// let crc = crc32(data, 0);
/// ```
pub fn crc32(input: &[u8], seed: u32) -> u32 {
    let mut crc = if seed == 0 { CRC_MAGIC } else { seed };

    for &byte in input {
        // Rotate left by 1 bit with carry (high bit becomes low bit)
        let carry = if crc & 0x80000000 != 0 { 1 } else { 0 };
        crc = (crc << 1) | carry;

        // XOR with current byte
        crc ^= byte as u32;
    }

    crc
}

/// Generate a pseudo-CRC32 from a counter value
///
/// Used for generating CRC values from sequential counter values.
/// This is useful for asset identification when you don't have the
/// actual asset data yet.
///
/// # Arguments
///
/// * `counter` - Counter value (typically increments)
///
/// # Returns
///
/// Generated pseudo-CRC32
///
/// # Example
///
/// ```
/// use thepalace::algo::pseudo_crc32;
///
/// let crc1 = pseudo_crc32(1);
/// let crc2 = pseudo_crc32(2);
/// assert_ne!(crc1, crc2);
/// ```
pub fn pseudo_crc32(counter: u32) -> u32 {
    let mut crc = 0xA95ADE76u32;
    let ctr_bytes = counter.to_be_bytes();

    for &byte in &ctr_bytes {
        // Rotate left by 1 bit
        crc = crc.wrapping_shl(1) | (crc >> 31);

        // XOR with byte and mask
        crc = (crc ^ (byte as u32)) ^ CRC_MASK[byte as usize];
    }

    crc
}

/// Palace encryption lookup table
///
/// Generated from seed 666666 using the Park-Miller PRNG algorithm.
/// This table contains 512 random bytes (values 0-255) used for the
/// XOR cipher. The original Palace used this same table for compatibility.
///
/// Original C initialization:
/// ```c
/// MySRand(666666L);
/// for (i = 0; i < 512; ++i)
///     gEncryptTable[i] = MyRandom(256);
/// ```
const ENCRYPT_TABLE: [u8; 512] = [
    0x37, 0xc5, 0x60, 0x72, 0xcd, 0xa5, 0x0b, 0x06, 0xd1, 0xf9, 0xcb, 0x3c, 0x57, 0x0c, 0x0d, 0x1b,
    0x79, 0x1e, 0x2d, 0x72, 0xb4, 0x04, 0xb3, 0x60, 0xb2, 0x80, 0xdd, 0x89, 0xa0, 0xed, 0xf2, 0x84,
    0x7c, 0xfa, 0xc4, 0x99, 0x9f, 0x27, 0xed, 0xde, 0x6c, 0xde, 0x1e, 0xb8, 0x48, 0x34, 0x64, 0x29,
    0x76, 0xa5, 0x01, 0x86, 0x21, 0x0b, 0xbf, 0xb0, 0x99, 0xed, 0x20, 0x2d, 0x75, 0x42, 0x4c, 0x6a,
    0xc0, 0x75, 0x7e, 0x89, 0x33, 0x00, 0x65, 0x82, 0x03, 0x04, 0x93, 0x3d, 0x57, 0x4a, 0xaa, 0x2f,
    0xa5, 0xd5, 0x74, 0xbd, 0xd7, 0x31, 0xda, 0x83, 0x96, 0xe2, 0x18, 0x59, 0xee, 0x20, 0x53, 0x24,
    0x3d, 0x88, 0xab, 0x77, 0x4a, 0x99, 0xb9, 0x04, 0xe1, 0xd3, 0x9d, 0xd0, 0x89, 0xbf, 0x89, 0x44,
    0x32, 0x64, 0xc7, 0x2e, 0x93, 0x33, 0xd5, 0x6b, 0x29, 0x95, 0xbb, 0x3b, 0x82, 0x96, 0x3d, 0x60,
    0x26, 0xd0, 0x84, 0x5b, 0x45, 0x5a, 0x8b, 0x4c, 0x5a, 0x3c, 0x5b, 0x8a, 0x58, 0x94, 0xb8, 0x9b,
    0x13, 0xdb, 0x6b, 0xbe, 0x1a, 0x0a, 0x60, 0x73, 0x74, 0x55, 0xe7, 0x59, 0xb0, 0xba, 0x44, 0x76,
    0xac, 0xe2, 0x85, 0x16, 0xc4, 0x10, 0x53, 0x97, 0x38, 0xc0, 0xee, 0xa8, 0x06, 0x42, 0xa9, 0x1b,
    0xbd, 0xd2, 0x97, 0xe2, 0xdd, 0x25, 0xda, 0xa5, 0x44, 0xc7, 0x20, 0x51, 0x3a, 0xfb, 0x92, 0x94,
    0x17, 0x71, 0x2f, 0x02, 0x55, 0x60, 0x96, 0xb5, 0x26, 0x4c, 0x57, 0xf7, 0x8b, 0x46, 0x78, 0x19,
    0xe2, 0xb6, 0x60, 0x8f, 0xd0, 0xf7, 0x94, 0x69, 0x04, 0x2d, 0xc5, 0x41, 0xd2, 0x40, 0x83, 0x89,
    0x67, 0xc7, 0xee, 0xf5, 0x5d, 0xa7, 0x89, 0x31, 0xd7, 0x92, 0x52, 0x57, 0xd8, 0xa7, 0x10, 0xf6,
    0xd3, 0x14, 0x8a, 0x12, 0x76, 0x7f, 0x1a, 0xe2, 0x17, 0xd5, 0xb1, 0xff, 0x7e, 0x82, 0xd8, 0x32,
    0xb3, 0x89, 0x1d, 0xb2, 0x44, 0x6a, 0x78, 0xaf, 0x0f, 0x23, 0xf9, 0x64, 0x7a, 0x3b, 0x7a, 0x13,
    0x21, 0x50, 0x86, 0x80, 0x07, 0x47, 0x98, 0xbc, 0x84, 0x24, 0x6e, 0xe0, 0xab, 0x84, 0xde, 0xdc,
    0x01, 0x20, 0xed, 0x03, 0x02, 0x99, 0xa3, 0x2f, 0x9e, 0x89, 0x67, 0x03, 0x69, 0xc5, 0xa5, 0x2e,
    0x12, 0xb1, 0x54, 0x5f, 0xd3, 0x36, 0xf9, 0x80, 0xdc, 0x37, 0x5f, 0x23, 0x69, 0xb2, 0xcb, 0x39,
    0x99, 0x7b, 0xe9, 0x59, 0x63, 0x28, 0x09, 0x05, 0xb6, 0x92, 0xaa, 0x45, 0x79, 0x54, 0xd4, 0xe3,
    0x2d, 0x6b, 0x6c, 0x5a, 0xa7, 0x29, 0xe7, 0x6c, 0x66, 0x95, 0x40, 0xc9, 0x2d, 0xce, 0x33, 0x39,
    0x55, 0x66, 0xca, 0x7e, 0xd1, 0x7a, 0xc0, 0x20, 0x40, 0x09, 0x4e, 0x29, 0xb3, 0xde, 0x09, 0xcd,
    0x99, 0xae, 0xfb, 0x18, 0xad, 0x73, 0xd5, 0x7e, 0xba, 0x02, 0x5b, 0x8f, 0x5c, 0xa3, 0xf9, 0xa9,
    0x2b, 0xf2, 0x63, 0xde, 0x98, 0x2f, 0x26, 0x99, 0x28, 0xca, 0xbe, 0xef, 0x77, 0x72, 0xae, 0xc8,
    0x5d, 0x29, 0x72, 0x6c, 0x2a, 0x18, 0x3b, 0x8b, 0xa1, 0x15, 0xac, 0x1e, 0x5d, 0x09, 0x48, 0x7d,
    0xdd, 0x2c, 0xab, 0x8a, 0x07, 0xe4, 0x4a, 0xa4, 0x6b, 0x96, 0x11, 0x88, 0xcd, 0x9c, 0x30, 0x15,
    0xcf, 0x55, 0x12, 0xf1, 0x82, 0x4c, 0x04, 0x24, 0xec, 0xa8, 0xae, 0xd2, 0x1c, 0x2e, 0x1c, 0x12,
    0x42, 0x9a, 0xe8, 0x20, 0x64, 0x5c, 0xbf, 0xde, 0xe8, 0xf4, 0xe5, 0x4c, 0x77, 0xe4, 0x51, 0xb0,
    0x26, 0xda, 0xa7, 0x86, 0xf3, 0x10, 0xb4, 0x86, 0xe8, 0x0e, 0x79, 0x91, 0x4e, 0xde, 0x75, 0x7b,
    0xd5, 0xd1, 0xd7, 0xaa, 0x16, 0xbd, 0x5b, 0x03, 0xa5, 0x31, 0x38, 0x93, 0x33, 0x66, 0xf2, 0x0e,
    0x6f, 0x10, 0xa8, 0xd8, 0x35, 0x95, 0x50, 0x2d, 0xa1, 0x3f, 0xfd, 0x06, 0x09, 0x90, 0x86, 0xcc,
];

/// Encrypt or decrypt data using Palace's XOR cipher
///
/// Palace uses a simple XOR-based cipher with a lookup table for
/// password encryption and other security-critical strings.
/// The algorithm processes data **backwards** (from last byte to first)
/// using chained XOR operations.
///
/// **Security Note:** This is NOT secure by modern standards. It's
/// a legacy algorithm kept for protocol compatibility. Do NOT use
/// this for actual security in new applications.
///
/// Original C implementation:
/// ```c
/// void EncryptString(StringPtr inStr, StringPtr outStr)
/// {
///     int i, rc = 0;
///     unsigned char lastChar = 0;
///     
///     outStr[0] = inStr[0];
///     for (i = inStr[0]; i > 0; --i) {
///         outStr[i] = inStr[i] ^ gEncryptTable[rc++] ^ lastChar;
///         lastChar = outStr[i] ^ gEncryptTable[rc++];
///     }
/// }
/// ```
///
/// # Arguments
///
/// * `input` - Data to encrypt/decrypt (max 254 bytes)
/// * `decrypting` - True for decryption, false for encryption
///
/// # Returns
///
/// * `Ok(Vec<u8>)` - Encrypted/decrypted data
/// * `Err(PalaceCryptError::Length)` - Input too long
///
/// # Example
///
/// ```
/// use thepalace::algo::crypt;
///
/// let plaintext = b"password";
/// let encrypted = crypt(plaintext, false).unwrap();
/// let decrypted = crypt(&encrypted, true).unwrap();
/// assert_eq!(plaintext, &decrypted[..]);
/// ```
pub fn crypt(input: &[u8], decrypting: bool) -> Result<Vec<u8>, PalaceCryptError> {
    if input.len() > 254 {
        return Err(PalaceCryptError::Length(254, input.len()));
    }

    if input.is_empty() {
        return Ok(Vec::new());
    }

    let mut output = vec![0u8; input.len()];
    let mut rc = 0usize;
    let mut last_char = 0u8;

    // Process backwards through the string (from last to first)
    for i in (0..input.len()).rev() {
        // XOR with lookup table and last byte
        output[i] = input[i] ^ ENCRYPT_TABLE[rc] ^ last_char;
        rc += 1;

        // Update last_char based on mode
        // For encryption: lastChar = outStr[i] ^ gEncryptTable[rc++]
        // For decryption: lastChar = tmp ^ gEncryptTable[rc++] (where tmp = inStr[i])
        last_char = if decrypting {
            input[i] ^ ENCRYPT_TABLE[rc]
        } else {
            output[i] ^ ENCRYPT_TABLE[rc]
        };
        rc += 1;
    }

    Ok(output)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_crc32_empty() {
        let crc = crc32(b"", 0);
        // Empty data returns CRC_MAGIC unchanged
        assert_eq!(crc, CRC_MAGIC);
    }

    #[test]
    fn test_crc32_simple() {
        let data = b"Hello";
        let crc = crc32(data, 0);
        assert_ne!(crc, 0);
    }

    #[test]
    fn test_crc32_different_data() {
        let crc1 = crc32(b"Hello", 0);
        let crc2 = crc32(b"World", 0);
        assert_ne!(crc1, crc2);
    }

    #[test]
    fn test_crc32_with_seed() {
        let data = b"Test";
        let crc1 = crc32(data, 0);
        let crc2 = crc32(data, 0x12345678);
        assert_ne!(crc1, crc2);
    }

    #[test]
    fn test_pseudo_crc32_different_counters() {
        let crc1 = pseudo_crc32(1);
        let crc2 = pseudo_crc32(2);
        let crc3 = pseudo_crc32(3);

        assert_ne!(crc1, crc2);
        assert_ne!(crc2, crc3);
        assert_ne!(crc1, crc3);
    }

    #[test]
    fn test_pseudo_crc32_deterministic() {
        let crc1 = pseudo_crc32(42);
        let crc2 = pseudo_crc32(42);
        assert_eq!(crc1, crc2);
    }

    #[test]
    fn test_crypt_roundtrip() {
        let plaintext = b"Hello, Palace!";
        let encrypted = crypt(plaintext, false).unwrap();
        let decrypted = crypt(&encrypted, true).unwrap();

        assert_eq!(plaintext, &decrypted[..]);
    }

    #[test]
    fn test_crypt_changes_data() {
        let plaintext = b"password";
        let encrypted = crypt(plaintext, false).unwrap();

        // Encrypted should be different from plaintext
        assert_ne!(plaintext, &encrypted[..]);
    }

    #[test]
    fn test_crypt_max_length() {
        let data = vec![0u8; 254];
        assert!(crypt(&data, false).is_ok());
    }

    #[test]
    fn test_crypt_too_long() {
        let data = vec![0u8; 255];
        let result = crypt(&data, false);

        assert!(matches!(result, Err(PalaceCryptError::Length(254, 255))));
    }

    #[test]
    fn test_crypt_empty() {
        let encrypted = crypt(b"", false).unwrap();
        assert_eq!(encrypted.len(), 0);
    }

    #[test]
    fn test_crypt_password_example() {
        // Typical use case: encrypting username:password
        let auth = b"user:pass";
        let encrypted = crypt(auth, false).unwrap();
        let decrypted = crypt(&encrypted, true).unwrap();

        assert_eq!(auth, &decrypted[..]);
        assert_ne!(encrypted, auth);
    }
}
